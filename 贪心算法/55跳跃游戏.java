/*
核心思想：我们并不关心每一步具体跳到了哪里，而是关心在当前步骤之后，最远可以跳到哪里。
我们通过不断更新 mx 来记录当前最远能到达的地方。

剪枝优化：通过 if (i > mx)，我们可以提前终止算法的运行。
当发现某个位置不可达时，直接返回 false，这样节省了不必要的计算。

贪心算法：这是一个典型的贪心算法，它的贪心策略是每一步都选择能跳得最远的选择。
通过这种方式，我们能尽快确定是否能够到达最后一个位置。
 */
class Solution {
    public boolean canJump(int[] nums) {
        int mx = 0;  // 初始化最远可以到达的位置为 0
        for (int i = 0; mx < nums.length - 1; i++) {
            if (i > mx) { // 如果当前位置 i 已经超过了最远可到达位置 mx，说明无法到达 i
                return false;
            }
            mx = Math.max(mx, i + nums[i]); // 更新最远可以到达的位置
        }
        return true; // 如果循环结束，没有提前返回 false，说明可以到达最后一个位置
    }

}

